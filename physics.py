import numpy as np
from scipy.spatial.transform import Rotation as R

import magpylib as magpy

def getFT(sources, observers, mass_center, eps=1e-6):
    """ 
    Compute force and torque acting on a center of mass through a set of
    observer magnets generated by a magnetic field from a set of source objects.
    
    Computation based on magnetic moment approximation (=point approx) for
    each observer magnet
    
    F = grad(m.B)
    T = m x B  +  F x r

    Parameters
    ----------
    sources: list of objects with .getB() method
        Generators of the magnetic field.
    observer: list or Collection of Magpylib Cuboid objects
        Force and Torque are computed through interaction between field
        and observers
    mass_center: array_like, shape (3,), unit [mm]
        Observer force and torque are computed with respect to center of mass
    eps: float, unit [mm]
        Discretization length used for central difference approximation for
        computation of the gradient.
    
    Returns
    -------
    FT: ndarray (F,T), shape (2,3)
        Force vector F in units of [N] and Torque vector T in units of [Nm]
    """

    # load observer properties
    pos = np.array([obs.position for obs in observers])
    rot = R.from_quat([obs.orientation.as_quat() for obs in observers])
    dim = np.array([obs.dimension for obs in observers])
    mag = np.array([obs.magnetization for obs in observers])
    
    vol = np.prod(dim, axis=1)       # observer volume, unit [mm^3]
    mag_glob = rot.apply(mag)        # observer magnetizations in global CS, unit [mT]
    mom_glob = (mag_glob.T * vol).T  # observer moments in global CS, unit = [T*m^3] * 1e-12 / mu0

    # compute field around observer position
    eps = 1e-6
    d_pos = np.array([(0,0,0), (eps,0,0), (-eps,0,0), (0,eps,0), (0,-eps,0), (0,0,eps), (0,0,-eps)])
    poso = np.array([d_pos + pp for pp in pos])
    B = magpy.getB(sources, poso, sumup=True, squeeze=False)  # unit = [T] * 1e-3
    B = B[0,0]

    # central difference representation of d/dr_i B_j
    gradB =(B[:,1::2]-B[:,2::2]) / (2*eps)          # unit = [mT/mm]
    
    # observer positions in center-of-mass (com) system
    pos_com = pos - mass_center
    pos_com_norm = np.linalg.norm(pos_com, axis=1)

    # compute forces F and Torques T
    gradB = np.swapaxes(gradB, 0, 1)
    Fi = np.sum(mom_glob * gradB, axis=2).T            # unit = [N] * 1e-5/(4*np.pi)
    Ti = np.cross(B[:,0], mom_glob, axisa=1)           # unit = [N*m] * 1e-8 / (4*np.pi)

    # if com != observer position, F adds a Torque of T = F x r
    mask = (pos_com_norm > 1e-14)
    if np.any(mask):
        Fi_s = Fi[mask]
        pos_com_s = pos_com[mask]                                # obs position relative to COM
        pos_com_s_unit = (pos_com_s.T / pos_com_norm[mask]).T    #    unit vector thereof
        Fi_s_project = np.sum(Fi_s * pos_com_s_unit, axis=1)     # component of F pointing in COM direction
        Fi_s_perp = Fi_s - (pos_com_s_unit.T * Fi_s_project).T   # perpendicular force vector
        Ti_s = np.cross(pos_com_s, Fi_s_perp)                    # resulting Torques
        
        Ti[mask] += Ti_s

    F = np.sum(Fi, axis=0) * 1e-5 / (4*np.pi) # unit [N]
    T = np.sum(Ti, axis=0) * 1e-8 / (4*np.pi) # unit [N*m]

    return np.array((F,T))


def mesh_cuboid(cuboid, nnn):
    """
    Splits Cuboid up into small Cuboid cells
    
    Parameters
    ----------
    cuboid: magpylib.Cuboid object
        input object to be discretized
    nnn: tuple, shape (3,), dtype=int
        discretization (nx,ny,nz)

    Returns
    -------
    discretization: magpylib.Collection
        Collection of Cuboid cells
    """

    # load cuboid properties
    pos = cuboid.position
    rot = cuboid.orientation
    dim = cuboid.dimension
    mag = cuboid.magnetization
    
    # secure input type
    nnn = np.array(nnn, dtype=int)

    # new dimension
    new_dim = dim/nnn

    # inside position grid
    xs,ys,zs = [np.linspace(d/2*(1/n-1), d/2*(1-1/n), n) for d,n in zip(dim,nnn)]
    grid = np.array([(x,y,z) for x in xs for y in ys for z in zs])
    grid = rot.apply(grid) + pos
    
    # create cells as magpylib objects ad return Collection
    cells = [magpy.magnet.Box(mag, new_dim, pp, rot) for pp in grid]
    
    return magpy.Collection(cells)






if __name__ == '__main__':
    src = magpy.magnet.Box((0,0,1000), (1,1,1), (0,0,0))
    obs = magpy.magnet.Box((1000,0,0), (1,1,2), (1.1,0,0))

    print()
    print('object-based')
    f,t = getFT([src], [obs], obs.position)
    print(f'F = {f}')
    print(f'T = {t}')

    print()
    cells = mesh_cuboid(obs, (3,12,12))
    magpy.display(cells)
    f,t = getFT([src], cells, obs.position)
    print(f'F = {f}')
    print(f'T = {t}')
