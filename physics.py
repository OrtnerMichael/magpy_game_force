import numpy as np
from scipy.spatial.transform import Rotation as R

import magpylib as magpy

def getFT(sources, observers, mass_center, eps=1e-6):
    """ 
    Compute force and torque acting on a center of mass through a set of
    observer magnets generated by a magnetic field from a set of source objects.
    
    Computation based on magnetic moment approximation (=point approx) for
    each observer magnet
    
    F = grad(m.B)
    T = m x B  +  F x r

    Parameters
    ----------
    sources: list of objects with .getB() method
        Generators of the magnetic field.
    observer: list or Collection of Magpylib Cuboid objects
        Force and Torque are computed through interaction between field
        and observers
    mass_center: array_like, shape (3,), unit [mm]
        Observer force and torque are computed with respect to center of mass
    eps: float, unit [mm]
        Discretization length used for central difference approximation for
        computation of the gradient.
    
    Returns
    -------
    FT: ndarray (F,T), shape (2,3)
        Force vector F in units of [N] and Torque vector T in units of [Nm]
    """

    # load observer properties
    pos = np.array([obs.position for obs in observers])
    rot = R.from_quat([obs.orientation.as_quat() for obs in observers])
    dim = np.array([obs.dimension for obs in observers])
    mag = np.array([obs.magnetization for obs in observers])
    
    vol = np.prod(dim, axis=1)       # observer volume, unit [mm^3]
    mag_glob = rot.apply(mag)        # observer magnetizations in global CS, unit [mT]
    mom_glob = (mag_glob.T * vol).T  # observer moments in global CS, unit = [T*m^3] * 1e-12 / mu0

    # compute field around observer position
    eps = 1e-6
    d_pos = np.array([(0,0,0), (eps,0,0), (-eps,0,0), (0,eps,0), (0,-eps,0), (0,0,eps), (0,0,-eps)])
    poso = np.array([d_pos + pp for pp in pos])
    B = magpy.getB(sources, poso, sumup=True, squeeze=False)  # unit = [T] * 1e-3
    B = B[0,0]

    # central difference representation of d/dr_i B_j
    gradB =(B[:,1::2]-B[:,2::2]) / (2*eps)          # unit = [mT/mm]
    
    # observer positions in center-of-mass (com) system
    pos_com = pos - mass_center
    pos_com_norm = np.linalg.norm(pos_com, axis=1)

    # compute forces F and Torques T
    gradB = np.swapaxes(gradB, 0, 1)
    Fi = np.sum(mom_glob * gradB, axis=2).T            # unit = [N] * 1e-5/(4*np.pi)
    Ti = np.cross(B[:,0], mom_glob, axisa=1)           # unit = [N*m] * 1e-8 / (4*np.pi)

    # if com != observer position, F adds a Torque of T = F x r
    mask = (pos_com_norm > 1e-14)
    if np.any(mask):
        Fi_s = Fi[mask]
        pos_com_s = pos_com[mask]                                # obs position relative to COM
        pos_com_s_unit = (pos_com_s.T / pos_com_norm[mask]).T    #    unit vector thereof
        Fi_s_project = np.sum(Fi_s * pos_com_s_unit, axis=1)     # component of F pointing in COM direction
        Fi_s_perp = Fi_s - (pos_com_s_unit.T * Fi_s_project).T   # perpendicular force vector
        Ti_s = np.cross(pos_com_s, Fi_s_perp)                    # resulting Torques
        
        Ti[mask] += Ti_s

    F = np.sum(Fi, axis=0) * 1e-5 / (4*np.pi) # unit [N]
    T = np.sum(Ti, axis=0) * 1e-8 / (4*np.pi) # unit [N*m]

    return np.array((F,T))


def mesh_cuboid(cuboid, nnn):
    """
    Splits Cuboid up into small Cuboid cells
    
    Parameters
    ----------
    cuboid: magpylib.Cuboid object
        input object to be discretized
    nnn: tuple, shape (3,), dtype=int
        discretization (nx,ny,nz)

    Returns
    -------
    discretization: magpylib.Collection
        Collection of Cuboid cells
    """

    # load cuboid properties
    pos = cuboid.position
    rot = cuboid.orientation
    dim = cuboid.dimension
    mag = cuboid.magnetization
    
    # secure input type
    nnn = np.array(nnn, dtype=int)

    # new dimension
    new_dim = dim/nnn

    # inside position grid
    xs,ys,zs = [np.linspace(d/2*(1/n-1), d/2*(1-1/n), n) for d,n in zip(dim,nnn)]
    grid = np.array([(x,y,z) for x in xs for y in ys for z in zs])
    grid = rot.apply(grid) + pos
    
    # create cells as magpylib objects ad return Collection
    cells = [magpy.magnet.Box(mag, new_dim, pp, rot) for pp in grid]
    
    return magpy.Collection(cells)


def collision_xy_cuboids(obj1, obj2):
    """
    2D collision with hyperplane separation. Assumption: Magpylib Cuboid objects
    stand upright in a plane parallel to the xy-plane.

    all obj1[i] tested against obj2[i]

    Parameters
    ----------
    obj1: list of Cuboid objects
        Objects tested against obj2 for collision
    obj2: list of Cuboid objects
        Objects tested against obj1 for collision
    
    Returns
    -------
    collision: int or None
        If there is no collision return None, else return i where collision
        happens.
    """

    # compute all Cuboid corners
    all_obj = obj1 + obj2
    n = len(obj1)

    dim = np.array([o.dimension for o in all_obj])
    pos = np.array([o.position for o in all_obj])
    rot = np.array([o.orientation.as_quat() for o in all_obj])
    rot4 = np.repeat(rot, 4, axis=0)
    rot4 = R.from_quat(rot4)
    pos4 = np.repeat(pos, 4, axis=0)
    all_rect = np.array([(d[0]*i/2, d[1]*j*i/2, 0)
        for d in dim for i in [1,-1] for j in [1,-1]])
    all_rect = rot4.apply(all_rect) + pos4
    all_rect = np.reshape(all_rect,(-1,4,3))

    # collide obj1->obj2 AND obj2->obj1
    SQ1 = all_rect[:,:,:2]
    SQ2 = np.r_[all_rect[n:,:,:2], all_rect[:n,:,:2]]
    # select planes
    C = SQ1[:,1]
    edge1 = (SQ1[:,0]-C)
    edge2 = (SQ1[:,2]-C)
    # "normalized" edges - avoid sqrt 
    edge1_lam = edge1/np.tile(np.sum(edge1**2, axis=1), (2,1)).T
    edge2_lam = edge2/np.tile(np.sum(edge2**2, axis=1),( 2,1)).T
    # "projections" - avoid sqrt
    SQ2_flip = np.swapaxes(SQ2,0,1)
    proj1 = np.sum((SQ2_flip-C)*edge1_lam,axis=2).T
    proj2 = np.sum((SQ2_flip-C)*edge2_lam,axis=2).T
    # collision test
    no_collision1 = np.all(proj1<0, axis=1) | np.all(proj1>1, axis=1) # all above or below
    no_collision2 = np.all(proj2<0, axis=1) | np.all(proj2>1, axis=1)
    no_collision = no_collision1 | no_collision2                      # on edge1 or edge2
    no_collision = no_collision[:n] | no_collision[n:]                # obj1->obj2 OR obj2->obj1

    for i,coll in enumerate(~no_collision):
        if coll:
            return i
    return None
